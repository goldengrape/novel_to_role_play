好的，这是一个非常有启发性的想法，它将我们项目的最终形态从一个Web应用转变为一个独立的桌面程序。这完全可行，并且使用纯Python GUI库可以创造出一种非常经典的、响应迅速的用户体验。

我们必须在这里做出一个至关重要的架构决策，这个决策将直接影响项目的成败，并检验我们对公理设计的忠诚度。

### **架构抉择：耦合 vs. 解耦 (Monolith vs. Client-Server)**

#### **方案一：耦合的单体应用 (强烈不推荐)**

*   **想法：** 在GUI应用中直接调用LLM生成函数。例如，点击一个按钮，该按钮的事件处理器直接调用`generation.create_csm_from_text()`。
*   **为何是陷阱：**
    1.  **UI冻结：** 这是最致命的问题。LLM调用是耗时极长的I/O操作（几十秒甚至几分钟）。在单体应用中，调用它会**完全阻塞GUI的主事件循环**。你的应用窗口会变成“（无响应）”状态，用户无法进行任何操作，体验极差。
    2.  **代码混乱：** UI布局代码、事件处理逻辑、复杂的Prompt链逻辑、数据校验代码会全部混杂在一起，形成“意大利面条式代码”。
    3.  **违背公理设计：** 这彻底摧毁了我们精心设计的解耦架构，将DP1（核心引擎）和DP3（前端）强行耦合在一起，违反了独立性公理。

#### **方案二：解耦的客户端-服务器模式 (强烈推荐)**

*   **想法：** 即使所有代码都在本地运行，我们依然坚持**“前后端分离”**的架构。
    *   **GUI应用 (客户端):** 这是一个纯粹的用户界面。它的唯一职责是接收用户输入，通过**本地HTTP请求**将任务发送给后端服务，然后通过轮询或长连接接收结果并展示。
    *   **FastAPI应用 (服务器):** 在后台默默运行，负责所有繁重的计算（LLM调用、数据处理）。
*   **为何是最佳实践：**
    1.  **UI响应性：** GUI应用在发送API请求后，可以立即返回，UI绝不会冻结。它可以在后台线程中进行API轮询，并用进度条、状态文本等方式给用户提供实时反馈。
    2.  **代码纯粹：** GUI代码只处理UI，后端代码只处理逻辑。职责清晰，易于维护。
    3.  **遵循公理设计：** 完美地在本地实现了DP1和DP3的独立性。我们可以更换GUI库（比如从Tkinter换到PyQt）而无需改动一行后端代码。
    4.  **复用我们已有的设计：** 我们之前设计的`run_local.py`启动器和SQLite数据库方案，完美地支持了这种模式。

**结论：我们将采纳方案二。** 我们会构建一个桌面GUI应用，但它将扮演一个API客户端的角色，与在本地运行的FastAPI后端服务通信。

### **选择一个GUI库：推荐 CustomTkinter**

既然要简单，又要界面美观，我推荐使用 **CustomTkinter**。
*   **简单:** 它是建立在Python标准库Tkinter之上的，学习曲线平缓。
*   **美观:** 它提供了现代、简洁、支持主题（明亮/黑暗）的组件，开箱即用。
*   **纯粹:** 它是一个纯Python库，安装简单 (`pip install customtkinter`)。

---

### **更新后的项目任务清单 (ToDo.md)**

好的，现在我将根据我们选择的 **本地纯Python桌面程序（CustomTkinter + FastAPI）** 方案，来更新项目任务清单。

# 项目任务清单 (ToDo.md)

- **当前阶段:** **工程实现 (Implementation Phase)**
- **指导原则:** 采用**解耦的客户端-服务器模式**在本地构建一个纯Python桌面应用。所有开发将基于已冻结的架构蓝图和技术合同。
    - **前端 (客户端):** 一个使用 **CustomTkinter** 构建的桌面GUI应用 (`DP3`)。
    - **后端 (服务器):** 一个使用 **FastAPI** 和 **SQLite** 构建的本地API服务 (`DP1`, `DP2`, `DP4`)。
    - **总启动器:** 一个`run_local.py`脚本，负责统一管理和启动前后端服务。

---

### **已完成里程碑 (Completed Milestones) - 设计阶段**

-   [x] **《用户需求文档 (URD) V1.4》** - **已冻结**
-   [x] **《公理设计文档 (ADD) V1.1》** - **已冻结**
-   [x] **《核心数据模型规约 (CDMS) V1.2》** - **已冻结**
-   [x] **《系统API规约 (SAS) V1.3》** - **已冻结**
-   [x] **《LLM Prompt工程与实现策略 (LLMPEIS) V1.1》** - **已冻结**

---

### **下一步行动计划 (Next Action Plan) - 工程实现阶段**

#### **第一部分：工程启动与基础设施搭建 (Phase 1: Kick-off & Infrastructure Setup)**

**目标:** 搭建支持本地客户端-服务器架构的开发环境。

1.  **[ ] 任务 1.1: 搭建项目管理看板** (无变化)
    *   **描述:** 在Jira或Trello中创建看板，根据DPs创建史诗。

2.  **[ ] 任务 1.2: 初始化代码仓库 (Monorepo)** (无变化)
    *   **描述:** 建立Git仓库，配置代码格式化与静态检查工具，将规约文档放入`/specs`目录。

3.  **[ ] 任务 1.3: 实现项目总启动器 (`run_local.py`)**
    *   **描述:** 编写`run_local.py`脚本，使用`subprocess`模块实现一键启动/关闭FastAPI后端和CustomTkinter前端两个独立进程。
    *   **目的:** 统一开发入口，简化本地运行流程。

4.  **[ ] 任务 1.4: 配置CI与契约测试** (无变化)
    *   **描述:** 建立CI流水线，其核心步骤是运行契约测试，确保FastAPI的实现严格遵守《系统API规约 V1.3》。

---

#### **第二部分：并行开发冲刺 (Phase 2: Parallel Development Sprints)**

**目标:** 各团队依据“技术合同”并行冲刺。

1.  **[ ] 工作流A: 核心引擎后端团队 (DP1, DP2, DP4 - Backend Team)**
    *   **聚焦:** 实现FastAPI后端服务和LLM核心逻辑。
    *   **任务:**
        *   **[ ] 2A.1:** 实现基于 **SQLite** 的任务状态管理模块 (`db.py`)。
        *   **[ ] 2A.2:** 实现符合《系统API规约 V1.3》的所有FastAPI端点。
        *   **[ ] 2A.3:** 根据《LLMPEIS V1.1》编写和测试 **CSM生成工作流** 的Prompt链。

2.  **[ ] 工作流B: 桌面GUI客户端团队 (DP3 - Frontend GUI Team)**
    *   **聚焦:** 使用CustomTkinter开发一个响应流畅、用户友好的桌面客户端。
    *   **关键挑战:** **在后台线程中处理API调用，防止UI冻结。**
    *   **任务:**
        *   **[ ] 2B.1:** 设计并实现应用主窗口布局（文件上传区、状态显示区、内容展示区）。
        *   **[ ] 2B.2:** 实现**后台线程**中的API调用逻辑。例如，点击“创建项目”按钮后，在一个新线程中发送`POST /projects`请求。
        *   **[ ] 2B.3:** 实现**后台轮询机制**，在独立的线程中定期调用`GET /projects/{id}`，并将返回的状态实时更新到GUI的标签或进度条上。
        *   **[ ] 2B.4:** 创建用于展示CSM（如使用树状视图或格式化文本框）和角色剧本的GUI组件。

---

#### **第三部分：集成、端到端测试与调优 (Phase 3: Integration, E2E Testing & Tuning)**

**目标:** 将客户端与后端无缝集成，进行完整功能测试和性能调优。

1.  **[ ] 任务 3.1: 全功能集成测试**
    *   **行动:** 使用`run_local.py`启动整个应用，模拟完整用户流程：上传小说 -> 查看CSM生成 -> 配置GSM -> 查看最终剧本和线索。
    *   **重点检查:** 确保在后端处理任务时，GUI界面始终保持响应。

2.  **[ ] 任务 3.2: LLM Prompt调优** (无变化)
    *   **描述:** 基于集成测试的结果，对Prompt模板和过程变量进行迭代优化。

3.  **[ ] 任务 3.3: 实现导出功能 (DP2)** (无变化)
    *   **描述:** 在后端实现`/projects/{id}/export`接口。在前端GUI中添加一个“导出游戏包”按钮，该按钮会触发API调用，并在完成后提示用户文件已保存。

4.  **[ ] 任务 3.4: 打包为可执行文件 (可选)**
    *   **描述:** 使用 **PyInstaller** 或 **cx_Freeze** 等工具，将整个Python项目（包括启动器、GUI客户端和后端服务）打包成一个独立的`.exe`（Windows）或`.app`（macOS）文件，方便非开发人员使用。

这份更新后的计划完全适配了我们新的技术选型，并坚守了公理设计的核心原则。

Gemini 2.5 Pro 0605